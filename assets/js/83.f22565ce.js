(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{521:function(a,s,e){"use strict";e.r(s);var t=e(34),n=Object(t.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("事务：一个操作假如有若干个操作或步骤，在任何操作出现一个错误的情况下，所有操作的效果必须被撤消，数据应被回滚到以前的状态,所有数据更改均被清除")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("1．原子性\n")])])]),e("p",[a._v("事务必须是原子工作单元。对于其数据修改，要么全都执行，要么全都不执行。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("2．一致性\n")])])]),e("p",[a._v("事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构都必须是正确的。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("3．隔离性\n")])])]),e("p",[a._v("由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务识别数据时数据所处的状态，或者是另一个并发事务修改它之前的状态，或者是第二个事务修改它之后的状态，事务不会识别中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("4．持久性\n")])])]),e("p",[a._v("事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。"),e("br"),a._v("\n事务有以下 3 种运行模式。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("    自动提交事务：每条单独的语句都是一个事务。\n    显式事务：每个事务均以BEGIN TRANSACTION语句显式开始，以COMMIT或ROLLBACK语句显式结束。\n    隐性事务：在上个事务完成时新事务隐式启动，但每个事务仍以COMMIT或ROLLBACK语句显式完成。\n")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);